#  1. 求节点的哈夫曼的带权路径长度
【问题描述】
 已知输入一串正整数，正整数之间用空格键分开，请建立一个哈夫曼树，以输入的数字为叶节点，求这棵哈夫曼树的带权路径长度。

【输入形式】
 首先输入正整数的个数，然后接下来为接下来的正整数，正整数个数不超过10个

【输出形式】
 输出相应的权值

【样例输入】
 5 4 5 6 7 8

【样例输出】
 69

 * 建立haffuman树
   * 把node 放在一个队列里
   * 每次取出最小的两个，构建一个新的node
   * 把新node放在队列里
   * 当队列长度为1时，队列里的就是头节点
 * 关键是：维持队列的有序（采用堆）
   * 优先队列
 * 计算带权路径
   * dfs里加入一个参数代表当前路径长度
   * 当遇到叶结点时返回该叶结点的WPL（Weighted Path Length）
  
# 2. 二叉排序树的构建及其遍历
【问题描述】
 对一组输入数据构建相应的二叉排序树，并利用其中序遍历对数据进行升序排序。（此题人工批改，必须使用二叉树进行排序，其它算法不得分）

【输入形式】
 数据个数，数据。(以空格分割)

【输出形式】
 排序之后的数据。(以空格分割)

【样例输入】
 5 22 -15 4 89 30

【样例输出】
 -15 4 22 30 89

 * 递归的构建BST(Binary Search Tree)
   * 根据BST的定义，所有左子树结点都小于根结点。所有右子树的结点都大于根结点
     * 所有的左子树是一颗BST
     * 所有右子树是一颗BST

# 3. 从下至上按层遍历二叉树
【问题描述】
 给定一颗二叉树，要求从下至上按层遍历二叉树，每层的访问顺序是从左到右，每一层单独输出一行。

【输入形式】
 广义表表示的二叉树，结点元素类型为整型，且都大于0，例如：1( 2( 3 ( 4, 5 ) ), 6( 7, 8( 9, 10 ) ) )

【输出形式】
 从下至上，打印每一层的结点元素值，元素间以空格隔开。每层的访问顺序是从左到右，每一层单独输出一行。

【样例输入】
 1(2(3(4,5)),6(7,8(9,10)))，字符串内没有空格

【样例输出】
 4 5 9 10
 3 7 8
 2 6
 1

 * 通过广义表构建二叉树
   * 用一个栈来存储结点
   * 左括号，下一个结点是当前栈顶的左孩子，入栈
   * 右括号，出栈
   * ，先出栈，当前结点是新栈顶的右孩子，入栈
   * 因此需要一个标记，记录上一次的符号是什么
 * 从下至上遍历二叉树
   * 用一个队列实现层序遍历
     * 队列里是当前层的所有结点构成的vector
   * 经过一个栈，实现从下到上 

# 4. 已知一个二叉树的中序遍历序列和后序遍历序列，求这棵树的前序遍历序列
【问题描述】
 已知一个二叉树的中序遍历序列和后序遍历序列，求这棵树的前序遍历序列。

【输入形式】
 一个树的中序遍历序列 该树后序遍历序列，中间用空格分开。输入序列中仅含有小写字母,且没有重复的字母

【输出形式】
 一个树的前序遍历序列

【样例输入】
 dbeafcg debfgca

【样例输出】
 abdecfg
 * leetcode 106
 * 递归的构建树
   * 找到根结点（后序的最后一个）
   * 通过中序确定左子树长度与右子树长度
     * 结合后序确定左右子树的后序与中序
     * 递归的构建左右子树
   * 出口：左右子树的长度<=0
  
# 5. 二叉查找树的后序遍历
【问题描述】输入一个整数数组，判断该数组是不是某二元查找树的后序遍历的结果。如果是返回true，否则返回false。
【输入形式】输入任意长度的数组，数字之间空格分开
【输出形式】true 或者 false
【样例输入】输入5 7 6 9 11 10 8
【样例输出】true
【样例说明】由于这一整数序列是如下树的后序遍历结果：

         8
       /  \
      6    10
    / \    / \
   5   7   9  11

因此返回true。
* BST的中序遍历是一个递增的序列
  * 通过后序与中序可以确定左右子树
    * 递归的判断左右子树是一个BST
  * 当左右子树的长度等于1的时候是BST